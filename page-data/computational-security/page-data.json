{"componentChunkName":"component---src-templates-mdx-template-js","path":"/computational-security/","result":{"data":{"mdx":{"frontmatter":{"title":"Computational Security"},"body":"# Computational Security\r\n\r\nThe concept of perfect secrecy represents an ideal in cryptography, ensuring\r\nthat no information about an encrypted message is ever leaked, even if an\r\nattacker has unlimited computational power. While this is theoretically\r\nappealing, it is unnecessarily strong and impractical for real-world\r\napplications.\r\nInstead, cryptographic security is commonly defined using the notion of\r\ncomputational security, which allows for minimal and practically negligible\r\nrisks. For instance, an encryption scheme may be considered secure if the\r\nprobability of an attacker successfully decrypting a message is infinitely small,\r\neven after decades of computational effort on advanced systems.\r\nComputational security differs fundamentally from perfect secrecy in two ways:\r\n1. Limited Adversary Resources: Security is guaranteed only against attackers with   feasible computational resources and time limits. Given unlimited resources, any system could potentially be compromised, but computational security ensures this scenario is practically unattainable.\r\n\r\n2. Minimal Probability of Failure: There is a small, non-zero chance of an attacker succeeding. By ensuring this probability is negligible, the risk remains acceptable in practical applications. Despite these relaxations, computational security maintains a rigorous mathematical framework. Definitions and proofs remain essential to establish and evaluate the strength of encryption schemes.\r\n\r\nTo formalize computational security, two main approaches are used:\r\n\r\n- The Concrete Approach\r\n\r\n- The Asymptotic Approach\r\n"}},"pageContext":{"id":"13c2fb56-a4b2-5c88-b81a-98b9e2cd1cde"}},"staticQueryHashes":["63159454"],"slicesMap":{}}